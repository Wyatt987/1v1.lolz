<!DOCTYPE html>
<html>
<head>
    <title>1v1 Style Game – Build Mode Version</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial; }
        #ui {
            position:absolute;top:10px;left:10px;color:white;
            background:rgba(0,0,0,0.35);padding:10px;border-radius:6px;
        }
    </style>
</head>
<body>

<div id="ui">
    <b>Controls</b><br>
    Move: WASD • Mouse Look: Move Mouse<br>
    <span id="modeText">Mode: Play</span><br>
    In Build Mode: Click to place, Z=Wall, X=Floor, C=Ramp, V=Cone, R=Rotate, Q=Exit Build Mode<br>
    Editing: Hold E + Aim → Click to delete<br>
    Out of Build Mode: Click to shoot, Q=Enter Build Mode
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>

<script>
/* ---------------------------------------------------
    SCENE SETUP
----------------------------------------------------*/
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(
    75, window.innerWidth/window.innerHeight, 0.1, 1000
);
camera.rotation.order = "YXZ";

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(5,10,8);
scene.add(sun);

/* ---------------------------------------------------
    FLOOR
----------------------------------------------------*/
const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(200,200),
    new THREE.MeshLambertMaterial({ color: 0x3c3c3c })
);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

/* ---------------------------------------------------
    PLAYER
----------------------------------------------------*/
const player = new THREE.Object3D();
player.position.set(0,1.6,5);
scene.add(player);

const body = new THREE.Mesh(
    new THREE.CapsuleGeometry(0.5,1.2,8,16),
    new THREE.MeshStandardMaterial({ color:0x00ffc8 })
);
body.position.y = -0.1;
player.add(body);

/* ---------------------------------------------------
    INPUT
----------------------------------------------------*/
const keys = {};
document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

// JUMP / VERTICAL PHYSICS
let velY = 0; // vertical velocity
const gravity = -0.03; // gravity acceleration per frame
const jumpStrength = 0.65; // initial jump impulse
let onGround = true;

// Spacebar to jump — use code so it works reliably across layouts
document.addEventListener('keydown', e => {
    if (e.code === 'Space') {
        e.preventDefault();
        if (onGround) {
            velY = jumpStrength;
            onGround = false;
        }
    }
});

document.body.onclick = ()=> document.body.requestPointerLock();

/* ---------------------------------------------------
    MOUSE LOOK
----------------------------------------------------*/
let camYaw = 0;
let camPitch = 0;

document.addEventListener('mousemove', e => {
    if (document.pointerLockElement === document.body) {
        camYaw -= e.movementX * 0.002;
        camPitch -= e.movementY * 0.002;
        camPitch = Math.max(-0.9, Math.min(0.9, camPitch));
    }
});

/* ---------------------------------------------------
    CAMERA FOLLOW
----------------------------------------------------*/
function updateCamera(){
    const distance = 6;
    const height = 2;

    const offset = new THREE.Vector3(
        Math.sin(camYaw) * distance,
        height,
        Math.cos(camYaw) * distance
    );

    camera.position.copy(player.position).add(offset);

    const lookTarget = player.position.clone();
    lookTarget.y += 1.2;

    camera.lookAt(lookTarget);
    camera.rotateX(camPitch);
}

/* ---------------------------------------------------
    SHOOTING
----------------------------------------------------*/
const bullets = [];

function shoot(){
    const bullet = new THREE.Mesh(
        new THREE.SphereGeometry(0.1),
        new THREE.MeshBasicMaterial({color:0xff0000})
    );
    bullet.position.copy(camera.position);

    let dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    bullet.velocity = dir.multiplyScalar(0.8);

    bullets.push(bullet);
    scene.add(bullet);
}

/* ---------------------------------------------------
    GRID SNAP
----------------------------------------------------*/
function snapToGrid(vec, gridSize = 3){
    return new THREE.Vector3(
        Math.round(vec.x / gridSize) * gridSize,
        Math.round(vec.y / gridSize) * gridSize,
        Math.round(vec.z / gridSize) * gridSize
    );
}

/* ---------------------------------------------------
    BUILDING SYSTEM
----------------------------------------------------*/
let buildModeActive = false;
let buildMode = "wall";
let rotateAmount = 0;
const builds = [];
const modeText = document.getElementById("modeText");

/* ----------- BUILD PREVIEW ----------- */
let previewMesh = null;

function createPreviewMesh(){
    let geom;
    const previewMat = new THREE.MeshLambertMaterial({
        color: 0x55aaff,
        transparent: true,
        opacity: 0.45
    });

    switch(buildMode){
        case "wall": geom = new THREE.BoxGeometry(3,3,0.3); break;
        case "floor": geom = new THREE.PlaneGeometry(3,3); break;
        case "ramp": geom = new THREE.BoxGeometry(3,1,3); break;
        case "cone": geom = new THREE.ConeGeometry(1.8,3,4); break;
    }

    if (previewMesh) scene.remove(previewMesh);
    previewMesh = new THREE.Mesh(geom, previewMat);
    previewMesh.renderOrder = 999;
    scene.add(previewMesh);
}

/* ---------------------------------------------------
    EDITING SYSTEM
----------------------------------------------------*/
const raycaster = new THREE.Raycaster();
let selectedBuild = null;

let highlightMat = new THREE.MeshLambertMaterial({
    color: 0x00aaff,
    transparent: true,
    opacity: 0.35
});
let highlightMesh = null;

let editingMode = false; // Hold E

document.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();

    // TOGGLE BUILD MODE
    if (k === 'q') {
        buildModeActive = !buildModeActive;
        modeText.textContent = "Mode: " + (buildModeActive ? "Build" : "Play");

        if (buildModeActive) {
            createPreviewMesh();
            if (highlightMesh) highlightMesh.visible = false;
        } else {
            if (previewMesh) previewMesh.visible = false;
        }

        return;
    }

    // Enter edit mode (HOLD E)
    if (k === "e") editingMode = true;

    if (!buildModeActive) return;

    if (k === 'z') { buildMode = "wall"; createPreviewMesh(); }
    if (k === 'x') { buildMode = "floor"; createPreviewMesh(); }
    if (k === 'c') { buildMode = "ramp"; createPreviewMesh(); }
    if (k === 'v') { buildMode = "cone"; createPreviewMesh(); }

    if (k === 'r') rotateAmount += Math.PI / 2;
});

document.addEventListener("keyup", ev => {
    if (ev.key.toLowerCase() === "e") {
        editingMode = false;
        selectedBuild = null;
        if (highlightMesh) highlightMesh.visible = false;
    }
});

/* ---------------------------------------------------
    PLACE BUILD
----------------------------------------------------*/
function build(){
    let geom;
    const mat = new THREE.MeshLambertMaterial({ color: 0x55aaff });

    switch(buildMode){
        case "wall": geom = new THREE.BoxGeometry(3,3,0.3); break;
        case "floor": geom = new THREE.PlaneGeometry(3,3); break;
        case "ramp": geom = new THREE.BoxGeometry(3,1,3); break;
        case "cone": geom = new THREE.ConeGeometry(1.8,3,4); break;
    }

    const obj = new THREE.Mesh(geom, mat);

    obj.position.copy(previewMesh.position);
    obj.rotation.copy(previewMesh.rotation);

    for (let b of builds) {
        if (b.position.distanceTo(obj.position) < 0.1) return;
    }

    builds.push(obj);
    scene.add(obj);
}

/* ---------------------------------------------------
    DELETE BUILD
----------------------------------------------------*/
document.addEventListener('mousedown', () => {

    // Editing active? Delete selected build
    if (editingMode && selectedBuild) {
        scene.remove(selectedBuild);
        builds.splice(builds.indexOf(selectedBuild), 1);

        if (highlightMesh) highlightMesh.visible = false;
        selectedBuild = null;
        return;
    }

    // Building mode
    if (buildModeActive) {
        build();
    } else {
        shoot();
    }
});

/* ---------------------------------------------------
    UPDATE EDITING (HIGHLIGHT)
----------------------------------------------------*/
function updateEditing() {
    if (!editingMode) return;

    raycaster.setFromCamera({ x: 0, y: 0 }, camera);

    const hits = raycaster.intersectObjects(builds);

    if (hits.length === 0) {
        if (highlightMesh) highlightMesh.visible = false;
        selectedBuild = null;
        return;
    }

    const hit = hits[0].object;

    // Must be close enough to edit
    if (camera.position.distanceTo(hit.position) > 15) {
        if (highlightMesh) highlightMesh.visible = false;
        selectedBuild = null;
        return;
    }

    selectedBuild = hit;

    if (!highlightMesh) {
        highlightMesh = new THREE.Mesh(hit.geometry, highlightMat);
        highlightMesh.renderOrder = 998;
        scene.add(highlightMesh);
    }

    highlightMesh.position.copy(hit.position);
    highlightMesh.rotation.copy(hit.rotation);
    highlightMesh.visible = true;
}

/* ---------------------------------------------------
    UPDATE PREVIEW
----------------------------------------------------*/
function updatePreview(){
    if (!previewMesh || !buildModeActive) return;

    const forward = new THREE.Vector3(0,0,-5)
        .applyAxisAngle(new THREE.Vector3(0,1,0), camYaw);

    let pos = player.position.clone().add(forward);
    pos = snapToGrid(pos, 3);
    previewMesh.position.copy(pos);

    previewMesh.rotation.set(0, camYaw + rotateAmount, 0);

    if (buildMode === "floor") previewMesh.rotation.x = -Math.PI/2;
    if (buildMode === "ramp") previewMesh.rotation.x = -Math.PI/4;
    if (buildMode === "cone") previewMesh.rotation.x = Math.PI;

    // Overlap color
    let blocked = false;
    for (let b of builds) {
        if (b.position.distanceTo(previewMesh.position) < 0.1) {
            blocked = true;
            break;
        }
    }

    previewMesh.material.color.set(blocked ? 0xff3333 : 0x55aaff);
}

/* ---------------------------------------------------
    GAME LOOP
----------------------------------------------------*/
function animate(){
    requestAnimationFrame(animate);

    const forward = new THREE.Vector3(Math.sin(camYaw),0,Math.cos(camYaw));
    const right = new THREE.Vector3(forward.z,0,-forward.x);

    if (keys['w']) player.position.add(forward.clone().multiplyScalar(-0.12));
    if (keys['s']) player.position.add(forward.clone().multiplyScalar(0.12));
    if (keys['a']) player.position.add(right.clone().multiplyScalar(-0.12));
    if (keys['d']) player.position.add(right.clone().multiplyScalar(0.12));

    // Vertical physics: apply gravity and vertical velocity
    velY += gravity;
    player.position.y += velY;

    // Support calculation: ground + builds (allows standing on placed objects)
    const eyeHeight = 1.6; // camera/player eye height above surface
    let supportY = 0 + eyeHeight; // ground plane at y=0

    for (let b of builds) {
        // compute world AABB for the build
        const box = new THREE.Box3().setFromObject(b);

        // check horizontal overlap (x/z). Small padding to be generous when stepping on edges
        const pad = 0.1;
        if (player.position.x >= box.min.x - pad && player.position.x <= box.max.x + pad &&
            player.position.z >= box.min.z - pad && player.position.z <= box.max.z + pad) {

            // candidate stand Y is top of the build plus eye height
            const topY = box.max.y;
            const candidate = topY + eyeHeight;

            // choose the highest available support under the player
            if (candidate > supportY) supportY = candidate;
        }
    }

    // apply support (land on ground or builds)
    if (player.position.y <= supportY) {
        player.position.y = supportY;
        velY = 0;
        onGround = true;
    } else {
        onGround = false;
    }

    updateCamera();
    updatePreview();
    updateEditing();

    for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].position.add(bullets[i].velocity);
        if (bullets[i].position.length() > 250){
            scene.remove(bullets[i]);
            bullets.splice(i,1);
        }
    }

    renderer.render(scene,camera);
}

animate();
</script>

</body>
</html>
