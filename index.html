<!DOCTYPE html>
<html>
<head>
    <title>1v1 Style Game – Build Mode Version</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial; }
        #ui {
            position:absolute;top:10px;left:10px;color:white;
            background:rgba(0,0,0,0.35);padding:10px;border-radius:6px;
        }
    </style>
</head>
<body>

<div id="ui">
    <b>Controls</b><br>
    Move: WASD • Mouse Look: Move Mouse<br>
    <span id="modeText">Mode: Play</span><br>
    In Build Mode: Click to place, Z=Wall, X=Floor, C=Ramp, V=Cone, R=Rotate, Q=Exit Build Mode<br>
    Out of Build Mode: Click to shoot, Q=Enter Build Mode
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>

<script>
/* ---------------------------------------------------
    SCENE SETUP
----------------------------------------------------*/
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(
    75, window.innerWidth/window.innerHeight, 0.1, 1000
);
camera.rotation.order = "YXZ";

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// lighting
const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(5,10,8);
scene.add(sun);

/* ---------------------------------------------------
    FLOOR
----------------------------------------------------*/
const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(200,200),
    new THREE.MeshLambertMaterial({ color: 0x3c3c3c })
);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

/* ---------------------------------------------------
    PLAYER
----------------------------------------------------*/
const player = new THREE.Object3D();
player.position.set(0,1.6,5);
scene.add(player);

const body = new THREE.Mesh(
    new THREE.CapsuleGeometry(0.5,1.2,8,16),
    new THREE.MeshStandardMaterial({ color:0x00ffc8 })
);
body.position.y = -0.1;
player.add(body);

/* ---------------------------------------------------
    INPUT
----------------------------------------------------*/
const keys = {};
document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

document.body.onclick = ()=> document.body.requestPointerLock();

/* ---------------------------------------------------
    MOUSE LOOK
----------------------------------------------------*/
let camYaw = 0;
let camPitch = 0;

document.addEventListener('mousemove', e => {
    if (document.pointerLockElement === document.body) {
        camYaw -= e.movementX * 0.002;
        camPitch -= e.movementY * 0.002;
        camPitch = Math.max(-0.9, Math.min(0.9, camPitch));
    }
});

/* ---------------------------------------------------
    CAMERA FOLLOW
----------------------------------------------------*/
function updateCamera(){
    const distance = 6;
    const height = 2;

    const offset = new THREE.Vector3(
        Math.sin(camYaw) * distance,
        height,
        Math.cos(camYaw) * distance
    );

    camera.position.copy(player.position).add(offset);

    const lookTarget = player.position.clone();
    lookTarget.y += 1.2;

    camera.lookAt(lookTarget);
    camera.rotateX(camPitch);
}

/* ---------------------------------------------------
    SHOOTING
----------------------------------------------------*/
const bullets = [];

function shoot(){
    const bullet = new THREE.Mesh(
        new THREE.SphereGeometry(0.1),
        new THREE.MeshBasicMaterial({color:0xff0000})
    );
    bullet.position.copy(camera.position);

    let dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    bullet.velocity = dir.multiplyScalar(0.8);

    bullets.push(bullet);
    scene.add(bullet);
}

/* ---------------------------------------------------
    GRID SNAP
----------------------------------------------------*/
function snapToGrid(vec, gridSize = 3){
    return new THREE.Vector3(
        Math.round(vec.x / gridSize) * gridSize,
        Math.round(vec.y / gridSize) * gridSize,
        Math.round(vec.z / gridSize) * gridSize
    );
}

/* ---------------------------------------------------
    BUILDING
----------------------------------------------------*/
let buildModeActive = false;
let buildMode = "wall";
let rotateAmount = 0;
const builds = [];

const modeText = document.getElementById("modeText");

document.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();

    // TOGGLE BUILD MODE
    if (k === 'q') {
        buildModeActive = !buildModeActive;
        modeText.textContent = "Mode: " + (buildModeActive ? "Build" : "Play");
        return;
    }

    if (!buildModeActive) return; // other keys do nothing outside build mode

    // Build selection
    if (k === 'z') buildMode = "wall";
    if (k === 'x') buildMode = "floor";
    if (k === 'c') buildMode = "ramp";
    if (k === 'v') buildMode = "cone";

    // Rotate build
    if (k === 'r') rotateAmount += Math.PI / 2;
});

function build(){
    let geom;
    const mat = new THREE.MeshLambertMaterial({ color: 0x55aaff });

    switch(buildMode){
        case "wall": geom = new THREE.BoxGeometry(3,3,0.3); break;
        case "floor": geom = new THREE.PlaneGeometry(3,3); break;
        case "ramp": geom = new THREE.BoxGeometry(3,1,3); break;
        case "cone": geom = new THREE.ConeGeometry(1.8,3,4); break;
    }

    const obj = new THREE.Mesh(geom, mat);

    // Placement in front of player
    const forward = new THREE.Vector3(0,0,-5)
        .applyAxisAngle(new THREE.Vector3(0,1,0), camYaw);

    let placePos = player.position.clone().add(forward);
    placePos = snapToGrid(placePos,3);
    obj.position.copy(placePos);

    obj.rotation.y = camYaw + rotateAmount;

    if (buildMode === "floor") obj.rotation.x = -Math.PI/2;
    if (buildMode === "ramp") obj.rotation.x = -Math.PI/4;
    if (buildMode === "cone") obj.rotation.x = Math.PI;

    // Prevent overlap
    for (let b of builds) {
        if (b.position.distanceTo(obj.position) < 0.1) return;
    }

    builds.push(obj);
    scene.add(obj);
}

/* ---------------------------------------------------
    MOUSE CLICK HANDLING
----------------------------------------------------*/
document.addEventListener('mousedown', () => {
    if (buildModeActive) {
        build();   // place build
    } else {
        shoot();   // shoot
    }
});

/* ---------------------------------------------------
    GAME LOOP
----------------------------------------------------*/
function animate(){
    requestAnimationFrame(animate);

    // movement
    const forward = new THREE.Vector3(Math.sin(camYaw),0,Math.cos(camYaw));
    const right = new THREE.Vector3(forward.z,0,-forward.x);

    if (keys['w']) player.position.add(forward.clone().multiplyScalar(-0.12));
    if (keys['s']) player.position.add(forward.clone().multiplyScalar(0.12));
    if (keys['a']) player.position.add(right.clone().multiplyScalar(-0.12));
    if (keys['d']) player.position.add(right.clone().multiplyScalar(0.12));

    updateCamera();

    // bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].position.add(bullets[i].velocity);
        if (bullets[i].position.length() > 250){
            scene.remove(bullets[i]);
            bullets.splice(i,1);
        }
    }

    renderer.render(scene,camera);
}

animate();
</script>
<script src="script.js"></script>
</body>
</html>
